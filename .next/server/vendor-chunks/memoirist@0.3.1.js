"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/memoirist@0.3.1";
exports.ids = ["vendor-chunks/memoirist@0.3.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/memoirist@0.3.1/node_modules/memoirist/dist/index.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/memoirist@0.3.1/node_modules/memoirist/dist/index.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Memoirist: () => (/* binding */ Memoirist),\n/* harmony export */   \"default\": () => (/* binding */ src_default)\n/* harmony export */ });\n// src/index.ts\nvar createNode = (part, inert) => {\n  const inertMap = inert?.length ? {} : null;\n  if (inertMap)\n    for (const child of inert)\n      inertMap[child.part.charCodeAt(0)] = child;\n  return {\n    part,\n    store: null,\n    inert: inertMap,\n    params: null,\n    wildcardStore: null\n  };\n};\nvar cloneNode = (node, part) => ({\n  ...node,\n  part\n});\nvar createParamNode = (name) => ({\n  name,\n  store: null,\n  inert: null\n});\nvar Memoirist = class _Memoirist {\n  constructor(config = {}) {\n    this.config = config;\n    if (config.lazy)\n      this.find = this.lazyFind;\n  }\n  root = {};\n  history = [];\n  deferred = [];\n  static regex = {\n    static: /:.+?(?=\\/|$)/,\n    params: /:.+?(?=\\/|$)/g,\n    optionalParams: /(\\/:\\w+\\?)/g\n  };\n  lazyFind = (method, url) => {\n    if (!this.config.lazy)\n      return this.find;\n    this.build();\n    return this.find(method, url);\n  };\n  build() {\n    if (!this.config.lazy)\n      return;\n    for (const [method, path, store] of this.deferred)\n      this.add(method, path, store, { lazy: false, ignoreHistory: true });\n    this.deferred = [];\n    this.find = (method, url) => {\n      const root = this.root[method];\n      if (!root)\n        return null;\n      return matchRoute(url, url.length, root, 0);\n    };\n  }\n  add(method, path, store, {\n    ignoreError = false,\n    ignoreHistory = false,\n    lazy = this.config.lazy\n  } = {}) {\n    if (lazy) {\n      this.find = this.lazyFind;\n      this.deferred.push([method, path, store]);\n      return store;\n    }\n    if (typeof path !== \"string\")\n      throw new TypeError(\"Route path must be a string\");\n    if (path === \"\")\n      path = \"/\";\n    else if (path[0] !== \"/\")\n      path = `/${path}`;\n    const isWildcard = path[path.length - 1] === \"*\";\n    const optionalParams = path.match(_Memoirist.regex.optionalParams);\n    if (optionalParams) {\n      const originalPath = path.replaceAll(\"?\", \"\");\n      this.add(method, originalPath, store, {\n        ignoreError,\n        ignoreHistory,\n        lazy\n      });\n      for (let i = 0; i < optionalParams.length; i++) {\n        let newPath = path.replace(optionalParams[i], \"\");\n        this.add(method, newPath, store, {\n          ignoreError: true,\n          ignoreHistory,\n          lazy\n        });\n      }\n      return store;\n    }\n    if (optionalParams)\n      path = path.replaceAll(\"?\", \"\");\n    if (this.history.find(([m, p, s]) => m === method && p === path))\n      return store;\n    if (isWildcard || optionalParams && path.charCodeAt(path.length - 1) === 63)\n      path = path.slice(0, -1);\n    if (!ignoreHistory)\n      this.history.push([method, path, store]);\n    const inertParts = path.split(_Memoirist.regex.static);\n    const paramParts = path.match(_Memoirist.regex.params) || [];\n    if (inertParts[inertParts.length - 1] === \"\")\n      inertParts.pop();\n    let node;\n    if (!this.root[method])\n      node = this.root[method] = createNode(\"/\");\n    else\n      node = this.root[method];\n    let paramPartsIndex = 0;\n    for (let i = 0; i < inertParts.length; ++i) {\n      let part = inertParts[i];\n      if (i > 0) {\n        const param = paramParts[paramPartsIndex++].slice(1);\n        if (node.params === null)\n          node.params = createParamNode(param);\n        else if (node.params.name !== param) {\n          if (ignoreError)\n            return store;\n          else\n            throw new Error(\n              `Cannot create route \"${path}\" with parameter \"${param}\" because a route already exists with a different parameter name (\"${node.params.name}\") in the same location`\n            );\n        }\n        const params = node.params;\n        if (params.inert === null) {\n          node = params.inert = createNode(part);\n          continue;\n        }\n        node = params.inert;\n      }\n      for (let j = 0; ; ) {\n        if (j === part.length) {\n          if (j < node.part.length) {\n            const childNode = cloneNode(node, node.part.slice(j));\n            Object.assign(node, createNode(part, [childNode]));\n          }\n          break;\n        }\n        if (j === node.part.length) {\n          if (node.inert === null)\n            node.inert = {};\n          const inert = node.inert[part.charCodeAt(j)];\n          if (inert) {\n            node = inert;\n            part = part.slice(j);\n            j = 0;\n            continue;\n          }\n          const childNode = createNode(part.slice(j));\n          node.inert[part.charCodeAt(j)] = childNode;\n          node = childNode;\n          break;\n        }\n        if (part[j] !== node.part[j]) {\n          const existingChild = cloneNode(node, node.part.slice(j));\n          const newChild = createNode(part.slice(j));\n          Object.assign(\n            node,\n            createNode(node.part.slice(0, j), [\n              existingChild,\n              newChild\n            ])\n          );\n          node = newChild;\n          break;\n        }\n        ++j;\n      }\n    }\n    if (paramPartsIndex < paramParts.length) {\n      const param = paramParts[paramPartsIndex];\n      const name = param.slice(1);\n      if (node.params === null)\n        node.params = createParamNode(name);\n      else if (node.params.name !== name) {\n        if (ignoreError)\n          return store;\n        else\n          throw new Error(\n            `Cannot create route \"${path}\" with parameter \"${name}\" because a route already exists with a different parameter name (\"${node.params.name}\") in the same location`\n          );\n      }\n      if (node.params.store === null)\n        node.params.store = store;\n      return node.params.store;\n    }\n    if (isWildcard) {\n      if (node.wildcardStore === null)\n        node.wildcardStore = store;\n      return node.wildcardStore;\n    }\n    if (node.store === null)\n      node.store = store;\n    return node.store;\n  }\n  find(method, url) {\n    const root = this.root[method];\n    if (!root)\n      return null;\n    return matchRoute(url, url.length, root, 0);\n  }\n};\nvar matchRoute = (url, urlLength, node, startIndex) => {\n  const part = node.part;\n  const length = part.length;\n  const endIndex = startIndex + length;\n  if (length > 1) {\n    if (endIndex > urlLength)\n      return null;\n    if (length < 15) {\n      for (let i = 1, j = startIndex + 1; i < length; ++i, ++j)\n        if (part.charCodeAt(i) !== url.charCodeAt(j))\n          return null;\n    } else if (url.slice(startIndex, endIndex) !== part)\n      return null;\n  }\n  if (endIndex === urlLength) {\n    if (node.store !== null)\n      return {\n        store: node.store,\n        params: {}\n      };\n    if (node.wildcardStore !== null)\n      return {\n        store: node.wildcardStore,\n        params: { \"*\": \"\" }\n      };\n    return null;\n  }\n  if (node.inert !== null) {\n    const inert = node.inert[url.charCodeAt(endIndex)];\n    if (inert !== void 0) {\n      const route = matchRoute(url, urlLength, inert, endIndex);\n      if (route !== null)\n        return route;\n    }\n  }\n  if (node.params !== null) {\n    const { store, name, inert } = node.params;\n    const slashIndex = url.indexOf(\"/\", endIndex);\n    if (slashIndex !== endIndex) {\n      if (slashIndex === -1 || slashIndex >= urlLength) {\n        if (store !== null) {\n          const params = {};\n          params[name] = url.substring(endIndex, urlLength);\n          return {\n            store,\n            params\n          };\n        }\n      } else if (inert !== null) {\n        const route = matchRoute(url, urlLength, inert, slashIndex);\n        if (route !== null) {\n          route.params[name] = url.substring(endIndex, slashIndex);\n          return route;\n        }\n      }\n    }\n  }\n  if (node.wildcardStore !== null)\n    return {\n      store: node.wildcardStore,\n      params: {\n        \"*\": url.substring(endIndex, urlLength)\n      }\n    };\n  return null;\n};\nvar src_default = Memoirist;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVtb2lyaXN0QDAuMy4xL25vZGVfbW9kdWxlcy9tZW1vaXJpc3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLLG9CQUFvQixNQUFNLHFFQUFxRSxpQkFBaUI7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLLG9CQUFvQixLQUFLLHFFQUFxRSxpQkFBaUI7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9saGFcXERlc2t0b3BcXERFVlxcY29kaW5nLmdsb2JhbC13ZWJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG1lbW9pcmlzdEAwLjMuMVxcbm9kZV9tb2R1bGVzXFxtZW1vaXJpc3RcXGRpc3RcXGluZGV4Lm1qc3xyc2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG52YXIgY3JlYXRlTm9kZSA9IChwYXJ0LCBpbmVydCkgPT4ge1xuICBjb25zdCBpbmVydE1hcCA9IGluZXJ0Py5sZW5ndGggPyB7fSA6IG51bGw7XG4gIGlmIChpbmVydE1hcClcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluZXJ0KVxuICAgICAgaW5lcnRNYXBbY2hpbGQucGFydC5jaGFyQ29kZUF0KDApXSA9IGNoaWxkO1xuICByZXR1cm4ge1xuICAgIHBhcnQsXG4gICAgc3RvcmU6IG51bGwsXG4gICAgaW5lcnQ6IGluZXJ0TWFwLFxuICAgIHBhcmFtczogbnVsbCxcbiAgICB3aWxkY2FyZFN0b3JlOiBudWxsXG4gIH07XG59O1xudmFyIGNsb25lTm9kZSA9IChub2RlLCBwYXJ0KSA9PiAoe1xuICAuLi5ub2RlLFxuICBwYXJ0XG59KTtcbnZhciBjcmVhdGVQYXJhbU5vZGUgPSAobmFtZSkgPT4gKHtcbiAgbmFtZSxcbiAgc3RvcmU6IG51bGwsXG4gIGluZXJ0OiBudWxsXG59KTtcbnZhciBNZW1vaXJpc3QgPSBjbGFzcyBfTWVtb2lyaXN0IHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBpZiAoY29uZmlnLmxhenkpXG4gICAgICB0aGlzLmZpbmQgPSB0aGlzLmxhenlGaW5kO1xuICB9XG4gIHJvb3QgPSB7fTtcbiAgaGlzdG9yeSA9IFtdO1xuICBkZWZlcnJlZCA9IFtdO1xuICBzdGF0aWMgcmVnZXggPSB7XG4gICAgc3RhdGljOiAvOi4rPyg/PVxcL3wkKS8sXG4gICAgcGFyYW1zOiAvOi4rPyg/PVxcL3wkKS9nLFxuICAgIG9wdGlvbmFsUGFyYW1zOiAvKFxcLzpcXHcrXFw/KS9nXG4gIH07XG4gIGxhenlGaW5kID0gKG1ldGhvZCwgdXJsKSA9PiB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5sYXp5KVxuICAgICAgcmV0dXJuIHRoaXMuZmluZDtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluZChtZXRob2QsIHVybCk7XG4gIH07XG4gIGJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5jb25maWcubGF6eSlcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIHBhdGgsIHN0b3JlXSBvZiB0aGlzLmRlZmVycmVkKVxuICAgICAgdGhpcy5hZGQobWV0aG9kLCBwYXRoLCBzdG9yZSwgeyBsYXp5OiBmYWxzZSwgaWdub3JlSGlzdG9yeTogdHJ1ZSB9KTtcbiAgICB0aGlzLmRlZmVycmVkID0gW107XG4gICAgdGhpcy5maW5kID0gKG1ldGhvZCwgdXJsKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gdGhpcy5yb290W21ldGhvZF07XG4gICAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG1hdGNoUm91dGUodXJsLCB1cmwubGVuZ3RoLCByb290LCAwKTtcbiAgICB9O1xuICB9XG4gIGFkZChtZXRob2QsIHBhdGgsIHN0b3JlLCB7XG4gICAgaWdub3JlRXJyb3IgPSBmYWxzZSxcbiAgICBpZ25vcmVIaXN0b3J5ID0gZmFsc2UsXG4gICAgbGF6eSA9IHRoaXMuY29uZmlnLmxhenlcbiAgfSA9IHt9KSB7XG4gICAgaWYgKGxhenkpIHtcbiAgICAgIHRoaXMuZmluZCA9IHRoaXMubGF6eUZpbmQ7XG4gICAgICB0aGlzLmRlZmVycmVkLnB1c2goW21ldGhvZCwgcGF0aCwgc3RvcmVdKTtcbiAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJvdXRlIHBhdGggbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpZiAocGF0aCA9PT0gXCJcIilcbiAgICAgIHBhdGggPSBcIi9cIjtcbiAgICBlbHNlIGlmIChwYXRoWzBdICE9PSBcIi9cIilcbiAgICAgIHBhdGggPSBgLyR7cGF0aH1gO1xuICAgIGNvbnN0IGlzV2lsZGNhcmQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiKlwiO1xuICAgIGNvbnN0IG9wdGlvbmFsUGFyYW1zID0gcGF0aC5tYXRjaChfTWVtb2lyaXN0LnJlZ2V4Lm9wdGlvbmFsUGFyYW1zKTtcbiAgICBpZiAob3B0aW9uYWxQYXJhbXMpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aCA9IHBhdGgucmVwbGFjZUFsbChcIj9cIiwgXCJcIik7XG4gICAgICB0aGlzLmFkZChtZXRob2QsIG9yaWdpbmFsUGF0aCwgc3RvcmUsIHtcbiAgICAgICAgaWdub3JlRXJyb3IsXG4gICAgICAgIGlnbm9yZUhpc3RvcnksXG4gICAgICAgIGxhenlcbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25hbFBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmV3UGF0aCA9IHBhdGgucmVwbGFjZShvcHRpb25hbFBhcmFtc1tpXSwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkKG1ldGhvZCwgbmV3UGF0aCwgc3RvcmUsIHtcbiAgICAgICAgICBpZ25vcmVFcnJvcjogdHJ1ZSxcbiAgICAgICAgICBpZ25vcmVIaXN0b3J5LFxuICAgICAgICAgIGxhenlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbFBhcmFtcylcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2VBbGwoXCI/XCIsIFwiXCIpO1xuICAgIGlmICh0aGlzLmhpc3RvcnkuZmluZCgoW20sIHAsIHNdKSA9PiBtID09PSBtZXRob2QgJiYgcCA9PT0gcGF0aCkpXG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgaWYgKGlzV2lsZGNhcmQgfHwgb3B0aW9uYWxQYXJhbXMgJiYgcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDYzKVxuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIGlmICghaWdub3JlSGlzdG9yeSlcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKFttZXRob2QsIHBhdGgsIHN0b3JlXSk7XG4gICAgY29uc3QgaW5lcnRQYXJ0cyA9IHBhdGguc3BsaXQoX01lbW9pcmlzdC5yZWdleC5zdGF0aWMpO1xuICAgIGNvbnN0IHBhcmFtUGFydHMgPSBwYXRoLm1hdGNoKF9NZW1vaXJpc3QucmVnZXgucGFyYW1zKSB8fCBbXTtcbiAgICBpZiAoaW5lcnRQYXJ0c1tpbmVydFBhcnRzLmxlbmd0aCAtIDFdID09PSBcIlwiKVxuICAgICAgaW5lcnRQYXJ0cy5wb3AoKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAoIXRoaXMucm9vdFttZXRob2RdKVxuICAgICAgbm9kZSA9IHRoaXMucm9vdFttZXRob2RdID0gY3JlYXRlTm9kZShcIi9cIik7XG4gICAgZWxzZVxuICAgICAgbm9kZSA9IHRoaXMucm9vdFttZXRob2RdO1xuICAgIGxldCBwYXJhbVBhcnRzSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5lcnRQYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgbGV0IHBhcnQgPSBpbmVydFBhcnRzW2ldO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gcGFyYW1QYXJ0c1twYXJhbVBhcnRzSW5kZXgrK10uc2xpY2UoMSk7XG4gICAgICAgIGlmIChub2RlLnBhcmFtcyA9PT0gbnVsbClcbiAgICAgICAgICBub2RlLnBhcmFtcyA9IGNyZWF0ZVBhcmFtTm9kZShwYXJhbSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyYW1zLm5hbWUgIT09IHBhcmFtKSB7XG4gICAgICAgICAgaWYgKGlnbm9yZUVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbm5vdCBjcmVhdGUgcm91dGUgXCIke3BhdGh9XCIgd2l0aCBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiIGJlY2F1c2UgYSByb3V0ZSBhbHJlYWR5IGV4aXN0cyB3aXRoIGEgZGlmZmVyZW50IHBhcmFtZXRlciBuYW1lIChcIiR7bm9kZS5wYXJhbXMubmFtZX1cIikgaW4gdGhlIHNhbWUgbG9jYXRpb25gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5vZGUucGFyYW1zO1xuICAgICAgICBpZiAocGFyYW1zLmluZXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IHBhcmFtcy5pbmVydCA9IGNyZWF0ZU5vZGUocGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHBhcmFtcy5pbmVydDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyA7ICkge1xuICAgICAgICBpZiAoaiA9PT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaiA8IG5vZGUucGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNsb25lTm9kZShub2RlLCBub2RlLnBhcnQuc2xpY2UoaikpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCBjcmVhdGVOb2RlKHBhcnQsIFtjaGlsZE5vZGVdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqID09PSBub2RlLnBhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaW5lcnQgPT09IG51bGwpXG4gICAgICAgICAgICBub2RlLmluZXJ0ID0ge307XG4gICAgICAgICAgY29uc3QgaW5lcnQgPSBub2RlLmluZXJ0W3BhcnQuY2hhckNvZGVBdChqKV07XG4gICAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgICBub2RlID0gaW5lcnQ7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydC5zbGljZShqKTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNyZWF0ZU5vZGUocGFydC5zbGljZShqKSk7XG4gICAgICAgICAgbm9kZS5pbmVydFtwYXJ0LmNoYXJDb2RlQXQoaildID0gY2hpbGROb2RlO1xuICAgICAgICAgIG5vZGUgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRbal0gIT09IG5vZGUucGFydFtqXSkge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGQgPSBjbG9uZU5vZGUobm9kZSwgbm9kZS5wYXJ0LnNsaWNlKGopKTtcbiAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNyZWF0ZU5vZGUocGFydC5zbGljZShqKSk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBjcmVhdGVOb2RlKG5vZGUucGFydC5zbGljZSgwLCBqKSwgW1xuICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkLFxuICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApO1xuICAgICAgICAgIG5vZGUgPSBuZXdDaGlsZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICArK2o7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbVBhcnRzSW5kZXggPCBwYXJhbVBhcnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbVBhcnRzW3BhcmFtUGFydHNJbmRleF07XG4gICAgICBjb25zdCBuYW1lID0gcGFyYW0uc2xpY2UoMSk7XG4gICAgICBpZiAobm9kZS5wYXJhbXMgPT09IG51bGwpXG4gICAgICAgIG5vZGUucGFyYW1zID0gY3JlYXRlUGFyYW1Ob2RlKG5hbWUpO1xuICAgICAgZWxzZSBpZiAobm9kZS5wYXJhbXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBpZiAoaWdub3JlRXJyb3IpXG4gICAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjcmVhdGUgcm91dGUgXCIke3BhdGh9XCIgd2l0aCBwYXJhbWV0ZXIgXCIke25hbWV9XCIgYmVjYXVzZSBhIHJvdXRlIGFscmVhZHkgZXhpc3RzIHdpdGggYSBkaWZmZXJlbnQgcGFyYW1ldGVyIG5hbWUgKFwiJHtub2RlLnBhcmFtcy5uYW1lfVwiKSBpbiB0aGUgc2FtZSBsb2NhdGlvbmBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUucGFyYW1zLnN0b3JlID09PSBudWxsKVxuICAgICAgICBub2RlLnBhcmFtcy5zdG9yZSA9IHN0b3JlO1xuICAgICAgcmV0dXJuIG5vZGUucGFyYW1zLnN0b3JlO1xuICAgIH1cbiAgICBpZiAoaXNXaWxkY2FyZCkge1xuICAgICAgaWYgKG5vZGUud2lsZGNhcmRTdG9yZSA9PT0gbnVsbClcbiAgICAgICAgbm9kZS53aWxkY2FyZFN0b3JlID0gc3RvcmU7XG4gICAgICByZXR1cm4gbm9kZS53aWxkY2FyZFN0b3JlO1xuICAgIH1cbiAgICBpZiAobm9kZS5zdG9yZSA9PT0gbnVsbClcbiAgICAgIG5vZGUuc3RvcmUgPSBzdG9yZTtcbiAgICByZXR1cm4gbm9kZS5zdG9yZTtcbiAgfVxuICBmaW5kKG1ldGhvZCwgdXJsKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdFttZXRob2RdO1xuICAgIGlmICghcm9vdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBtYXRjaFJvdXRlKHVybCwgdXJsLmxlbmd0aCwgcm9vdCwgMCk7XG4gIH1cbn07XG52YXIgbWF0Y2hSb3V0ZSA9ICh1cmwsIHVybExlbmd0aCwgbm9kZSwgc3RhcnRJbmRleCkgPT4ge1xuICBjb25zdCBwYXJ0ID0gbm9kZS5wYXJ0O1xuICBjb25zdCBsZW5ndGggPSBwYXJ0Lmxlbmd0aDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSkge1xuICAgIGlmIChlbmRJbmRleCA+IHVybExlbmd0aClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChsZW5ndGggPCAxNSkge1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGogPSBzdGFydEluZGV4ICsgMTsgaSA8IGxlbmd0aDsgKytpLCArK2opXG4gICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaSkgIT09IHVybC5jaGFyQ29kZUF0KGopKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodXJsLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSAhPT0gcGFydClcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbmRJbmRleCA9PT0gdXJsTGVuZ3RoKSB7XG4gICAgaWYgKG5vZGUuc3RvcmUgIT09IG51bGwpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdG9yZTogbm9kZS5zdG9yZSxcbiAgICAgICAgcGFyYW1zOiB7fVxuICAgICAgfTtcbiAgICBpZiAobm9kZS53aWxkY2FyZFN0b3JlICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcmU6IG5vZGUud2lsZGNhcmRTdG9yZSxcbiAgICAgICAgcGFyYW1zOiB7IFwiKlwiOiBcIlwiIH1cbiAgICAgIH07XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG5vZGUuaW5lcnQgIT09IG51bGwpIHtcbiAgICBjb25zdCBpbmVydCA9IG5vZGUuaW5lcnRbdXJsLmNoYXJDb2RlQXQoZW5kSW5kZXgpXTtcbiAgICBpZiAoaW5lcnQgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgcm91dGUgPSBtYXRjaFJvdXRlKHVybCwgdXJsTGVuZ3RoLCBpbmVydCwgZW5kSW5kZXgpO1xuICAgICAgaWYgKHJvdXRlICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnBhcmFtcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHsgc3RvcmUsIG5hbWUsIGluZXJ0IH0gPSBub2RlLnBhcmFtcztcbiAgICBjb25zdCBzbGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIvXCIsIGVuZEluZGV4KTtcbiAgICBpZiAoc2xhc2hJbmRleCAhPT0gZW5kSW5kZXgpIHtcbiAgICAgIGlmIChzbGFzaEluZGV4ID09PSAtMSB8fCBzbGFzaEluZGV4ID49IHVybExlbmd0aCkge1xuICAgICAgICBpZiAoc3RvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICAgICAgICBwYXJhbXNbbmFtZV0gPSB1cmwuc3Vic3RyaW5nKGVuZEluZGV4LCB1cmxMZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5lcnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBtYXRjaFJvdXRlKHVybCwgdXJsTGVuZ3RoLCBpbmVydCwgc2xhc2hJbmRleCk7XG4gICAgICAgIGlmIChyb3V0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJvdXRlLnBhcmFtc1tuYW1lXSA9IHVybC5zdWJzdHJpbmcoZW5kSW5kZXgsIHNsYXNoSW5kZXgpO1xuICAgICAgICAgIHJldHVybiByb3V0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobm9kZS53aWxkY2FyZFN0b3JlICE9PSBudWxsKVxuICAgIHJldHVybiB7XG4gICAgICBzdG9yZTogbm9kZS53aWxkY2FyZFN0b3JlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIFwiKlwiOiB1cmwuc3Vic3RyaW5nKGVuZEluZGV4LCB1cmxMZW5ndGgpXG4gICAgICB9XG4gICAgfTtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIHNyY19kZWZhdWx0ID0gTWVtb2lyaXN0O1xuZXhwb3J0IHtcbiAgTWVtb2lyaXN0LFxuICBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/memoirist@0.3.1/node_modules/memoirist/dist/index.mjs\n");

/***/ })

};
;